"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .imageinput import ImageInput, ImageInputTypedDict
from friendli.core.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from pydantic import model_serializer
from typing import List, Literal
from typing_extensions import NotRequired, TypedDict

ContainerImageGenerationBodyResponseFormat = Literal["raw", "jpeg"]


class ContainerImageGenerationBodyTypedDict(TypedDict):
    prompt: str
    "A text description of the desired image."
    num_inference_steps: int
    "The number of inference steps to use during image generation. Supported range: [1, 50]."
    guidance_scale: float
    "Adjusts the alignment of the generated image with the input prompt. Higher values (e.g., 8-10) make the output more faithful to the prompt, while lower values (e.g., 1-5) encourage more creative freedom. This parameter may be irrelevant for certain models, such as `FLUX.Schnell`."
    model: NotRequired[Nullable[str]]
    "Routes the request to a specific adapter."
    seed: NotRequired[Nullable[int]]
    "The seed to use for image generation."
    response_format: NotRequired[Nullable[ContainerImageGenerationBodyResponseFormat]]
    "The format in which the generated image will be returned. One of `raw` and `jpeg`."
    control_images: NotRequired[Nullable[List[ImageInputTypedDict]]]
    "Optional input images used to condition or guide the generation process (e.g., for ControlNet or image editing models). This field is only applicable when using ControlNet or image editing models."
    controlnet_weights: NotRequired[Nullable[List[float]]]
    "A list of weights that determine the influence of each ControlNet model in the generation process. Each value must be within [0, 1], where 0 disables the corresponding ControlNet and 1 applies it fully. When multiple ControlNet models are used, the list length must match the number of control images. If omitted, all ControlNet models default to full influence (1.0). This field is only applicable when using ControlNet models."


class ContainerImageGenerationBody(BaseModel):
    prompt: str
    "A text description of the desired image."
    num_inference_steps: int
    "The number of inference steps to use during image generation. Supported range: [1, 50]."
    guidance_scale: float
    "Adjusts the alignment of the generated image with the input prompt. Higher values (e.g., 8-10) make the output more faithful to the prompt, while lower values (e.g., 1-5) encourage more creative freedom. This parameter may be irrelevant for certain models, such as `FLUX.Schnell`."
    model: OptionalNullable[str] = UNSET
    "Routes the request to a specific adapter."
    seed: OptionalNullable[int] = UNSET
    "The seed to use for image generation."
    response_format: OptionalNullable[ContainerImageGenerationBodyResponseFormat] = (
        UNSET
    )
    "The format in which the generated image will be returned. One of `raw` and `jpeg`."
    control_images: OptionalNullable[List[ImageInput]] = UNSET
    "Optional input images used to condition or guide the generation process (e.g., for ControlNet or image editing models). This field is only applicable when using ControlNet or image editing models."
    controlnet_weights: OptionalNullable[List[float]] = UNSET
    "A list of weights that determine the influence of each ControlNet model in the generation process. Each value must be within [0, 1], where 0 disables the corresponding ControlNet and 1 applies it fully. When multiple ControlNet models are used, the list length must match the number of control images. If omitted, all ControlNet models default to full influence (1.0). This field is only applicable when using ControlNet models."

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "model",
            "seed",
            "response_format",
            "control_images",
            "controlnet_weights",
        ]
        nullable_fields = [
            "model",
            "seed",
            "response_format",
            "control_images",
            "controlnet_weights",
        ]
        null_default_fields = []
        serialized = handler(self)
        m = {}
        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)
            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )
            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                k not in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val
        return m
